#!/usr/bin/env python
# coding: utf-8

# # CMB Temperature Map Simulations
#Importing Necessary Modules

# This code creates unlensed Q & U maps of the CMB and phi map FFTs which can be used to lens them using QuickLens.
# It takes in a CMB spectrum generated by CAMB (https://camb.info/readme.html).
# #### Order matters here. The code breaks if you import pymaster after numpy or matplotlib.
# Import modules 
import pymaster as nmt
#import healpy
# If you prefer to work on spherical geometry you can use HEALPix/healpy -> conda install healpy -c conda-forge or pip install healpy
#Important! If you are using this in a notebook, import pymaster *before* any matplotlib/numpy to avoid OpenMP conflicts

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib
get_ipython().run_line_magic('matplotlib', 'inline')
import random
import flatmaps as fm
from astropy.wcs import WCS
from scipy.interpolate import interp1d

#Defining functions

#Function to concatenate [0,0] to spectrum to account for zeroed-out l-mode for 0 and 1 modes
#The simulation code, synfast_flat, interprets the first two numbers as the 0- and 1-mode.
#Since our spectrum starts at the second mode, I set the amplitude for the 0-mode and 1-mode to 0.
def add_zeroed_modes(spectrum, l_array=False):
    if l_array==False:
        concatenated_spectrum = np.concatenate(([0,0],spectrum))
    else:
        concatenated_spectrum = np.concatenate(([0,1],spectrum))
    return concatenated_spectrum

#Function for loading in CMB spectrum, returns dictionary containing l-modes and spectra
def load_cmb_spectra(location, fix_scaling=True, add_zeroed=True):
    #Loading in pregenerated spectra using CAMB
    #The file has l-modes plust the following spectra are respectively:
    #Temperature-Temperature, E mode-E mode, Temperature-E mode cross spectrum, Phi-Phi, Phi-Temperature cross
    l_modes, clTTa, clEEa, clTEa, clPPa, clPTa = np.loadtxt("planck_2018_cl/base_plikHM_TTTEEE_lowl_lowE_lensing_scalCls.dat", unpack=True)
    
    #CAMB scales spectra, so we fix that before feeding it into the map generation code
    if fix_scaling:
        clTTb = clTTa /((l_modes*(l_modes+1)/(2*np.pi)))
        clEEb = clEEa /((l_modes*(l_modes+1)/(2*np.pi)))
        clTEb = clTEa /((l_modes*(l_modes+1)/(2*np.pi)))
        clPPb = clPPa / (l_modes**4 * (2.726 * 1e6)**2)
        clPTb = clPTa / (l_modes**4 * (2.726 * 1e6)**2)
    
    #The simulation codes expect the l modes to start at 0, but CAMB has the lowest l-mode being 2.
    #Therefore, we add 0's to represent the lowest two modes below
    if add_zeroed:
        l_modes = add_zeroed_modes(l_modes, l_array=True)
        clTT = add_zeroed_modes(clTTb)
        clEE = add_zeroed_modes(clEEb)
        clTE = add_zeroed_modes(clTEb)
        clPP = add_zeroed_modes(clPPb)
        clPT = add_zeroed_modes(clPTb)
        
        #We then load the scaled spectra with added zeroes into a dictionary:
        cmb_spectra = {"l modes":l_modes, "clTT":clTT, "clTE":clTE, "clEE":clEE, "clPP":clPP, "clPT":clPT}
        
    elif fix_scaling:
        #If we don't want to add the zeroes (perhaps they were already added to the file), we load the scaled spectra only
        cmb_spectra = {"l modes":l_modes, "clTT":clTTb, "clTE":clTEb, "clEE":clEEb, "clPP":clPPb, "clPT":clPTb}
        
    else:
        cmb_spectra = {"l modes":l_modes, "clTT":clTTa, "cleTE":clTEa, "clEE":clEEa, "clPP":clPPa, "clPT":clPTa}
    return cmb_spectra
    
#Function for plotting spectrum
def spectrum_plot(l_modes, spectrum, title):
    fig = plt.figure()
    ax = plt.subplot(111)
    plt.plot(l_modes, spectrum, label=title)
    plt.xscale("log")
    plt.yscale("log")
    plt.tick_params(labelsize=15)
    plt.xlabel("$\mathit{l}$", fontsize=30)
    plt.ylabel("$\lambda K$", fontsize=30)
    plt.title("TT Spectrum", fontsize=24)
    ax.legend(bbox_to_anchor=(1.55, 1.0))
    
    return fig

#Function for plotting a 2D power spectrum or something in the frequency domain
def frequency_domain_plot(input_map_fft, title, scaling, colorbar_label):
    fig = plt.figure()
    plt.imshow(np.log10(np.abs(input_map_fft)), vmin=scaling[0], vmax=scaling[1])
    plt.colorbar(label=colorbar_label)
    plt.title(title)
    
    return fig

#Function for plotting 2D FFT
def calculate_and_plot_fft(input_map, title, real=False, scaling=[0,6], colorbar_label="Log of Map Strength"):
    #This needs to be an rfft for the actual analysis and a complex fft for estimating spectra
    if real:
        input_map_fft = np.fft.rfft2(input_map)
    else:
        input_map_fft = np.fft.fft2(input_map)

    fig = frequency_domain_plot(input_map_fft, title, scaling, colorbar_label)

    return fig

#Function for making 2D Power Map
def calculate_map_power_2D(input_map, tfac, real=False):
    #FFT needs to be real for the analysis and complex estimating spectra
    if real:
        input_map_fft = np.fft.rfft2(input_map)
    else:
        input_map_fft = np.fft.fft2(input_map)
    
    #Taking the conjugate of the phi map fft
    input_map_fft_conj = np.conj(input_map_fft)
    
    #Calculating the 2D Map Power
    map_power_2D = input_map_fft*input_map_fft_conj*tfac**2
    #input tfac accounts for conversion between frequency-domain and real-domain
    #it's calculated using map and fft parameters: tfac = resolution_in radians /pixels

    return map_power_2D

#Function for creating power spectrum plot
#This function has two methods: one which involves summing over annuli to estimate the power in different l-modes
#and a second method (which I took from Jo√£o Caldeira) that uses a histogram function to weight bins of l-modes
def calculate_power_spectrum(input_map, tfac, bin_num=80, pixels=192, lstep=72, method_histogram=False):
    #Calculate the maximum achievable l-mode given map parameters
    peak_l = pixels/2*lstep
    
    #This is the first (and default) method of calculating the power spectrum:
    if method_histogram==False:
        map_power_2D = calculate_map_power_2D(input_map, tfac, real=False)

        #Dividing data into four quarters, rotating so lowest mode is in top left quarter
        quarter1 = map_power_2D[:int(pixels/2),:int(pixels/2)]

        quarter2 = map_power_2D[:int(pixels/2),int(pixels/2+1):]
        quarter2 = np.rot90(quarter2)

        quarter3 = map_power_2D[int(pixels/2+1):,:int(pixels/2)]
        quarter3 = np.rot90(quarter3, k=3)

        quarter4 = map_power_2D[int(pixels/2+1):,int(pixels/2+1):]
        quarter4 = np.rot90(quarter4, k=2)

        #Creating empty arrays:
        spectra_est = np.zeros((bin_num)) #spectum sum before averaging
        spectra_est_avg_bins = np.zeros((bin_num)) #spectrum estimate after averaging
        n = np.zeros((bin_num))#number of points going into each bin/annulus

        #Defining edges of bins
        bin_edges = np.linspace(0,np.sqrt(2)*peak_l, bin_num+1)
    
        #Defining width of 1 bin
        bin_step = bin_edges[1]

        #Calculating bin centers
        bin_centers = (bin_edges[1:]+bin_edges[:-1])/2

        #Creating array containing each quarter of data
        quarter_list = [quarter1, quarter2, quarter3, quarter4]

        #Looping over each quarter
        for quarter in quarter_list:
    
            #Looping over row
            for i, spec in enumerate(quarter):
                lx_ = 72.*i #the l-mode in the x-direction
    
                #Looping over each pixel in each row
                for j, pwr in enumerate(quarter):
            
                    ly_ = 72.*j #the l-mode in the y-direction
            
                    #Calculate overall l-mode for each pixel
                    point_on_circ = np.sqrt(lx_**2+ly_**2) #overall l-mode

                    #Determine which been l-mode belongs to by seeing which is the largest lefthand edge smaller than pixel's overall l-mode
                    left_bin_edge = np.where(bin_edges <= point_on_circ)[0][-1] #largest bin that's smaller than overall l-mode
            
                    #Add power from that pixel to spectrum estimate
                    spectra_est[left_bin_edge] += map_power_2D[i,j] #adding power at coordinate (i,j) to bin
            
                    #Tally the pixel as being in this particular been (for averaging later)
                    n[left_bin_edge] += 1 #counting the number of points in the bin for averaging later
                
        #Divide the spectrum by the number of pixels that went into each bin
        spectra_est_avg_bins = spectra_est / n
        
    #This is the second (histogramming) method
    else:
        #Defining bin sizes
        lbins = np.linspace(0, peak_l, num=bin_num)
        bin_centers = 0.5*(lbins[0:-1] + lbins[1:])
        
        #Create grid to define l-mode in x- and y-directions and overall l as their geometric sum
        lx, ly = np.meshgrid(np.linspace(-peak_l+lstep, peak_l, int(pixels)),np.linspace(-peak_l+lstep, peak_l, int(pixels)))
        ell = np.sqrt(lx**2 + ly**2)
        
        #Histogramming l-modes into bins for normalization later 
        norm, bins = np.histogram(ell, bins=lbins)
        norm = norm.astype(float)
        norm[ np.where(norm != 0.0) ] = 1./norm[ np.where(norm != 0.0) ]
        
        #Create 2D power map
        temperature_map_real_fft = np.fft.fft2(input_map)
        temperature_map_real_fft_conj = np.conj(temperature_map_real_fft)
        real_map_power_2D = temperature_map_real_fft*temperature_map_real_fft_conj
        #"spectrum_2D" is the same as the powermap but recentered so the 0-mode is in the middle
        spectrum_2D = np.fft.fftshift(real_map_power_2D*tfac**2)
        
        #Histogramming l-modes from above, weighting by the 2D powerspectrum
        spectra_est_avg_bins, bins = np.histogram(ell, bins=lbins, weights=spectrum_2D)

        #Normalizing to account for different number of l-modes in eac bin
        spectra_est_avg_bins *= norm
    
    return bin_centers, spectra_est_avg_bins

#Function to plot a single or multiple spectra
#The spectra must be loaded with their own l-modes, you can not give a different number of l-modes and spectra
def plot_spectra(l_modes, spectra, plot_title, plot_labels):
    
    fig = plt.figure()
    
    #If there are multiple sets of l-modes, we plot them and their respective spectra
    if (type(l_modes) == list) and len(l_modes)>1:
        for i, spectrum in enumerate(spectra):
            plt.plot(l_modes[i],spectra[i],label=plot_labels[i])
            
    elif type(l_modes == np.ndarray) and len(np.shape(l_modes))>1:
        for i, spectrum in enumerate(spectra):
            plt.plot(l_modes[i],spectra[i],label=plot_labels[i])
            
        
    #If there's only one l-mode given, it's assumed you only gave it one spectrum
    #If you gave it multiple spectra for one l-mode, you fucked up.
    else:
        plt.plot(l_modes,spectra,label=plot_labels)
    
    plt.legend(loc="lower left")
    plt.yscale("log")
    plt.xscale("log")
    plt.title(plot_title)
    plt.xlabel("$l$ mode")
    plt.ylabel("$C_{l}$")
    return fig

#This function generates CMB maps.
#The spectra are assumed to be from CAMB, with the numbers rescaled and zeroes added to the front
#to account for CAMB beginning its spectra at l=2.
#This function can make temperature-only maps, OR temperature-only maps with Q and U modes,
#OR temperature-only maps with E and B modes, OR phi (gravitational deflection) maps only.

#fmi is flat-map info. It is basically a class which contains information about themaps and is an imported module.
def generate_maps(spectra_dict, fmi, num_maps, pixels, temp_only=False, TQU_maps=False, TEB_maps=False, phi_map=False, start_seed = 0):
    i=0
    
    #FIXME: I don't understand how to make the random seed work
    #if start_seed != 0:
    #    random.seed(a=start_seed)
    #else:
    #    random.seed()
        
    #random_num = random.getstate()[0]
    
    if sum([temp_only, TQU_maps, TEB_maps, phi_map])>1:
        print("You can only pick only one of these options: temperature-map only, TQU maps, TEB maps or phi_map.")
        return None
    
    #This part makes only temperature maps
    elif temp_only:
        
        #Creating an array to store all of the maps
        all_maps = np.zeros([num_maps,1,int(pixels),int(pixels)])
        
        #Loop to create all maps
        while i < num_maps:
            
            #Creating each individual map
            one_map_set = nmt.synfast_flat(int(fmi.nx),int(fmi.ny),fmi.lx_rad,fmi.ly_rad,np.array([spectra_dict["clTT"], spectra_dict["clTE"], spectra_dict["clTB"], spectra_dict["clEE"], spectra_dict["clEB"], spectra_dict["clBB"]]),[0,0,0])
                
            #Saving map in index i of array
            all_maps[i] = one_map_set
            
            #Printing how many maps have been finished (it can seem slow)
            if np.mod(i,100) == 0:
                print(i,)
            i+=1
        
    #This part makes temperature maps with their respective Q and U modes
    elif TQU_maps:
        
        #Creating an array to store all of the maps
        all_maps = np.zeros([num_maps,3,int(pixels),int(pixels)])
        
        #Loop to create all maps
        while i < num_maps:
            
            #Creating *one set* of temperature maps plus its Q and U maps
            one_map_set = nmt.synfast_flat(int(fmi.nx),int(fmi.ny),fmi.lx_rad,fmi.ly_rad,np.array([spectra_dict["clTT"], spectra_dict["clTE"], spectra_dict["clTB"], spectra_dict["clEE"], spectra_dict["clEB"], spectra_dict["clBB"]]),[0,2])
            
            #Saving all three maps in index i of array
            all_maps[i] = one_map_set
            
            #Printing how many maps have been finished (it can seem slow)
            if np.mod(i,100) == 0:
                print(i,)
            i+=1

    #This part makes temperature maps with their respective E and B modes
    elif TEB_maps:
        
        #Creating an array to store all the maps
        all_maps = np.zeros([num_maps,3,int(pixels),int(pixels)])
        
        #Loop to create all maps
        while i < num_maps:
            
            #Creating *one set* of temperature maps plus its E and B maps
            one_map_set = nmt.synfast_flat(int(fmi.nx),int(fmi.ny),fmi.lx_rad,fmi.ly_rad,np.array([spectra_dict["clTT"], spectra_dict["clTE"], spectra_dict["clTB"], spectra_dict["clEE"], spectra_dict["clEB"], spectra_dict["clBB"]]),[0,0,0])
            
            #Saving all three maps in index i of aray
            all_maps[i] = one_map_set
            
            #Printing how many maps have been finished (it can seem slow)
            if np.mod(i,100) == 0:
                print(i,)
            i+=1
            
    #This part makes phi maps only
    elif phi_map:
        
        #Creating an arrayto store all the maps
        all_maps = np.zeros([num_maps,1,int(pixels),int(pixels)])
        
        #Loop to create all maps
        #If these maps look odd, you may have forgotten to nomalize the phi spectrum from CAMB, which is done automatically using load_cmb_spectra.
        while i < num_maps:
            
            #Creating one phi (gravitational deflection) map
            one_map_set = nmt.synfast_flat(int(fmi.nx),int(fmi.ny),fmi.lx_rad,fmi.ly_rad, [spectra_dict["clPP"]],[0])
            
            #Saving map to index i of array
            all_maps[i] = one_map_set
            
            #Printing how many maps have been finished (it can seem slow)
            if np.mod(i,100) == 0:
                print(i,)
            i+=1
        
        
    else:
        print("What type of maps did you want?")
        return None
    
    return all_maps
